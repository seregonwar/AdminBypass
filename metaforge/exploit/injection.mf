// Funzioni per code injection
struct InjectionContext {
    HANDLE process;
    ptr code;
    u32 size;
    ptr remote_base;
}

fn prepare_injection(u32 pid, ptr code, u32 size) -> InjectionContext {
    let ctx = InjectionContext {
        process: OpenProcess(0x1F0FFF, false, pid),
        code: code,
        size: size,
        remote_base: null
    };
    
    if ctx.process == null {
        ret null;
    }
    
    // Allocate remote memory
    ctx.remote_base = VirtualAllocEx(
        ctx.process,
        null,
        size,
        0x3000,  // MEM_COMMIT | MEM_RESERVE
        0x40     // PAGE_EXECUTE_READWRITE
    );
    
    if ctx.remote_base == null {
        CloseHandle(ctx.process);
        ret null;
    }
    
    ret ctx;
}

fn inject_code(InjectionContext ctx) -> bool {
    // Write code to remote process
    let written = WriteProcessMemory(
        ctx.process,
        ctx.remote_base,
        ctx.code,
        ctx.size,
        null
    );
    
    if !written {
        ret false;
    }
    
    // Create remote thread
    let thread = CreateRemoteThread(
        ctx.process,
        null,
        0,
        ctx.remote_base,
        null,
        0,
        null
    );
    
    if thread == null {
        ret false;
    }
    
    CloseHandle(thread);
    ret true;
}

fn inject_dll(u32 pid, ptr dll_path) -> bool {
    let process = OpenProcess(0x1F0FFF, false, pid);
    if process == null {
        ret false;
    }
    
    // Allocate memory for DLL path
    let path_size = strlen(dll_path) + 1;
    let remote_path = VirtualAllocEx(
        process,
        null,
        path_size,
        0x3000,
        0x40
    );
    
    if remote_path == null {
        CloseHandle(process);
        ret false;
    }
    
    // Write DLL path
    WriteProcessMemory(process, remote_path, dll_path, path_size, null);
    
    // Get LoadLibraryA address
    let kernel32 = GetModuleHandleA("kernel32.dll");
    let load_library = GetProcAddress(kernel32, "LoadLibraryA");
    
    // Create remote thread
    let thread = CreateRemoteThread(
        process,
        null,
        0,
        load_library,
        remote_path,
        0,
        null
    );
    
    if thread == null {
        VirtualFreeEx(process, remote_path, 0, 0x8000);
        CloseHandle(process);
        ret false;
    }
    
    WaitForSingleObject(thread, -1);
    CloseHandle(thread);
    VirtualFreeEx(process, remote_path, 0, 0x8000);
    CloseHandle(process);
    
    ret true;
}