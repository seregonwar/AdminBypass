
#include <windows.h>
#include <winternl.h>

typedef struct _InjectionContext {
    HANDLE process;
    LPVOID code;
    SIZE_T size;
    LPVOID remoteBase;
} InjectionContext;

__declspec(dllexport) InjectionContext* __stdcall PrepareInjection(DWORD pid, LPVOID code, SIZE_T size) {
    InjectionContext* ctx = (InjectionContext*)malloc(sizeof(InjectionContext));
    if (!ctx) return NULL;
    
    ctx->process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!ctx->process) {
        free(ctx);
        return NULL;
    }
    
    ctx->remoteBase = VirtualAllocEx(ctx->process, NULL, size, 
                                   MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!ctx->remoteBase) {
        CloseHandle(ctx->process);
        free(ctx);
        return NULL;
    }
    
    ctx->code = code;
    ctx->size = size;
    return ctx;
}

__declspec(dllexport) BOOL __stdcall InjectCode(InjectionContext* ctx) {
    if (!ctx) return FALSE;
    
    SIZE_T written;
    if (!WriteProcessMemory(ctx->process, ctx->remoteBase, ctx->code, ctx->size, &written)) {
        return FALSE;
    }
    
    HANDLE thread = CreateRemoteThread(ctx->process, NULL, 0, 
                                     (LPTHREAD_START_ROUTINE)ctx->remoteBase, 
                                     NULL, 0, NULL);
    if (!thread) {
        return FALSE;
    }
    
    CloseHandle(thread);
    return TRUE;
}

__declspec(dllexport) BOOL __stdcall InjectDLL(DWORD pid, LPCSTR dllPath) {
    HANDLE process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!process) return FALSE;
    
    SIZE_T pathSize = strlen(dllPath) + 1;
    LPVOID remotePath = VirtualAllocEx(process, NULL, pathSize, 
                                     MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!remotePath) {
        CloseHandle(process);
        return FALSE;
    }
    
    if (!WriteProcessMemory(process, remotePath, dllPath, pathSize, NULL)) {
        VirtualFreeEx(process, remotePath, 0, MEM_RELEASE);
        CloseHandle(process);
        return FALSE;
    }
    
    HMODULE kernel32 = GetModuleHandleA("kernel32.dll");
    LPVOID loadLibrary = GetProcAddress(kernel32, "LoadLibraryA");
    
    HANDLE thread = CreateRemoteThread(process, NULL, 0, 
                                     (LPTHREAD_START_ROUTINE)loadLibrary,
                                     remotePath, 0, NULL);
    if (!thread) {
        VirtualFreeEx(process, remotePath, 0, MEM_RELEASE);
        CloseHandle(process);
        return FALSE;
    }
    
    WaitForSingleObject(thread, INFINITE);
    CloseHandle(thread);
    VirtualFreeEx(process, remotePath, 0, MEM_RELEASE);
    CloseHandle(process);
    
    return TRUE;
}
